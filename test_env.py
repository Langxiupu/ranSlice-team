import csv
import pickle
from turtle import position

from matplotlib.style import available
from commModule.UserTerminal import Position, UserTerminal
from commModule.UserTerminal import Distance
from commModule.leoSat import LEOSatellite
from commModule.mac_scheduler import MacScheduler
from common import utils
from common.tool import calc_ratio_vec
import random
common_satellites = [3743, 1666, 1644, 1143]
time_interval = 0.001
slice_interval = 0.01


# 根据用户终端位置的CSV文件读取用户终端位置汇集成字典
def read_positions_from_csv(file_path):
    position_dict = {}
    index = 1  # 从1开始的键值

    with open(file_path, 'r', encoding='utf-8') as csvfile:
        # 创建CSV读取器，指定制表符分隔
        reader = csv.DictReader(csvfile, delimiter=',')

        for row in reader:
            try:
                # 从行数据中提取纬度和经度
                lat = float(row['latitude'])
                lon = float(row['longitude'])

                # 创建Position对象并添加到字典
                position_dict[index] = Position(latitude=lat, longitude=lon)
                index += 1  # 递增键值
            except (KeyError, ValueError) as e:
                # 处理可能的数据缺失或格式错误
                print(f"跳过无效行: {row}. 错误: {e}")
    return position_dict


# 根据给定文件路径和公共可见卫星,时隙以及用户数量获取特定时隙下每个用户终端与公共卫星之间的距离信息,以Dict{Dict}形式存储
def get_info_by_time(file_path, time, common_satellites, num_users):
    with open(file_path, "rb") as f:
        visibles_t_u = pickle.load(f)  # 读取可见卫星数据
    if time < 0 or time >= len(visibles_t_u):
        print(f"Error: Time index {time} is out of range.")
        return
    time_slot = visibles_t_u[time]
    distance_dict = {}
    for user in range(1, num_users + 1):
        visible_sats = time_slot[user - 1]  # 获取用户在该时隙可见的所有卫星
        user_distances = {}
        for sat in common_satellites:
            visible_sat = visible_sats[sat] if sat in visible_sats else None
            if visible_sat is not None:
                distance = Distance(altitude=visible_sat.altitude,
                                    azimuth=visible_sat.azimuth,
                                    Range=visible_sat.range)
                user_distances[sat] = distance
        distance_dict[user] = user_distances
    return distance_dict


# 根据文件路径获取时隙数量
def slot_num(file_path):
    with open(file_path, "rb") as f:
        visibles_t_u = pickle.load(f)  # 读取可见卫星数据
    return len(visibles_t_u)  # 返回时隙数量

"""
重新配置可用用户终端
参数：
    available_terminals: 可用用户终端
    unavailable_terminals: 不可用用户终端
    num_available_terminals: 可用用户终端数量
"""
def config_terminals(available_terminals, unavailable_terminals, num_available_terminals):
    # 首先可用用户终端数不能超过总用户终端数
    if num_available_terminals > len(available_terminals)+len(unavailable_terminals):
        print("Error: num_available_terminals cannot be greater than the total number of available terminals.")
        return
    # 其次判断可用用户终端字典大小与可用用户终端数量之间的关系
    if len(available_terminals) < num_available_terminals:
        # 从不可用用户终端中随机选择用户终端加入到可用用户终端中，同时从不可用用户终端中删除
        for i in range(num_available_terminals-len(available_terminals)):
            terminal = random.choice(list(unavailable_terminals.keys()))
            available_terminals[terminal] = unavailable_terminals.pop(terminal)
    elif len(available_terminals) > num_available_terminals:
        # 从可用用户终端中随机选择用户终端加入到不可用用户终端中，同时从可用用户终端中删除
        for i in range(len(available_terminals)-num_available_terminals):
            terminal = random.choice(list(available_terminals.keys()))
            unavailable_terminals[terminal] = available_terminals.pop(terminal)
            # 同时需要与终端的卫星断开连接
            unavailable_terminals[terminal].disconnect_sat()


if __name__ == '__main__':
    """ test the correctness of the slice-mac env """

    #* 1. configure the satellite scenarios
    #* e.g., 15 satellites jointly provide access services to a given region.
    ...

    #* 2. configure the number of slices in each satellite
    #* suppose the category and the number are the same across all the satellites
    #* e.g., each sat has: 1 BW-intensive slice, 1 delay sensitive slice.
    ...

    #* 3. configure users and apps generated by each user.
    #* e.g., an app from one user is characterized by the packet size, packet rate, 
    #* BW and delay constraints.
    #* a data packet is the minimal transmission unit. In other words, 
    #* if the packet size is 1000 bits, and the transmission rate is 1000 bits/s,
    #* if the time start from 0s, there is no traffic between 0-1s, and 
    #* at 1s, a packet is generated. 
    ...

    #* 4. allocate each app to a slice
    #* the rule is: the apps with similar QoS requirements are grouped into the same slice. 
    #* suppose there is a typical service in each slice, calculate the Euclidean distance between 
    #* user's app (BW_u, Delay_u) and the the slice's typical service (BW_s, Delay_s), and assign 
    #* user's app to the slice with the smallest distance.
    ...

    #* 5. configure the MAC scheduler 
    #* assuming the MAC scheduler adopts round-robin as its scheduling policy. 
    #* configure the SCS and BW of the scheduler

    #* 6. consider a 10-slot resource scheduling, Each slot is scheduled once
    #* with a total of 10 slots advanced throughout the entire simulation.
    #* assuming we evenly divide the BW among slices. 
    #* at this stage, the input is the BW allocation of each slice,  the slice association, 
    #* and the data remains to be transmitted. 
    #* The input exmaple:
    #* BW allocation: slice A is allocated with 3RBs, the indices of RBs is [1, 10, 80]
    #* Output example: 
    #* in each slot, the allocation result should be a vector, 
    #* e.g., [1, 17, 5] means that the 0th RB is allocated to app1 for transmission. 
    ...

    #* 7. collects statistics on BW and delay
    #* the input is the allocation matrix across the 10 slots
    #* the output should be the transmission rate and delay for each app

    # 测试读取某一时隙下每个用户终端与公共卫星之间的距离信息
    # file_path = "data/visibles_t_u-46users.pkl"
    # time_slot = 0  # 假设我们要获取第一个时隙的信息
    # num_users = 46  # 假设有46个用户终端
    # distances = get_info_by_time(file_path, time_slot, common_satellites, num_users)
    # if distances:
    #     for user, user_distances in distances.items():
    #         print(f"User {user}:")
    #         for sat_id, distance in user_distances.items():
    #             print(f"  Satellite {sat_id}: Altitude={distance.altitude}, Azimuth={distance.azimuth}, Range={distance.range}")
    # else:
    #     print("No distances found or an error occurred.")
    user_path = "sat-data/visibles_t_u-46users.pkl"
    position_path = "data/random_users46.csv"
    # 首先根据common_satellites来创建对应的leoSat卫星列表对象
    leo_sats = [LEOSatellite(sat_id) for sat_id in common_satellites]
    # 根据用户终端位置的CSV文件读取用户终端位置
    position_dict = read_positions_from_csv(position_path)
    num_users = len(position_dict)
    # 遍历每个用户终端位置字典，创建对应的用户终端对象，我们记作当前可用终端对象
    user_terminals = {}
    # 同时要有一个存储当前不可用终端对象的字典
    unavailable_terminals = {}
    random.seed(42)  # 设置随机种子以确保可重复性
    all_users = {}  # 存储所有用户的字典，包括可用和不可用
    # 创建用户终端，初始下时全部用户终端都处于可用状态
    for user_id, pos in position_dict.items():
        flow_type = random.choice(["Voice", "V2X", "Video", "VR/AR"])  # 随机选择流类型
        user_terminal = UserTerminal(pos=pos, common_satellites=leo_sats, id=user_id, flow_type=flow_type)
        user_terminal.config_apps()
        user_terminal.config_flow_method("on-off")
        user_terminal.config_flow_params(0.5) # 配置流量生成方式
        user_terminals[user_id] = user_terminal
        all_users[user_id] = user_terminal
    num_users = len(user_terminals)
    slots = slot_num(user_path)
    # 根据slots的大小来创建一个当前可用终端占所有终端比例的列表，根据随机值在0~1之间随机生成
    ratio_vector = []
    # 创建MAC调度器
    scheduler = MacScheduler(BW=20e6, SCS=15e3, policy="RR", mac_slot_duration=1.0, simulation_duration=10000.0)
    print(f"MAC调度器初始化完成，总RB数: {scheduler.total_rbs}")
    # 遍历所有的卫星，将里面所有的slice添加到调度器中
    for sat in leo_sats:
        for slice in sat.slices:
            sat.config_mac(slice, scheduler, "add")
    # 将scheduler的total_rbs平均分配给每个slice
    BW_alloc ={}
    average_rbs = scheduler.total_rbs//len(scheduler.slices)
    current_rbs = 0
    # 遍历所有的slice，将RB平均分配给每个slice
    for slice_id, slice in scheduler.slices.items():
        if current_rbs + average_rbs <= scheduler.total_rbs:
            BW_alloc[slice_id] = list(range(current_rbs, current_rbs + average_rbs))
            current_rbs += average_rbs
        else:
            BW_alloc[slice_id] = list(range(current_rbs, scheduler.total_rbs))
    # 将所有的用户终端添加到调度器中
    for user_id, user_terminal in user_terminals.items():
        scheduler.add_ue(user_terminal)
    
    # 设置用户活跃度
    # available = calc_ratio_vec()
    for i in range(0, slots):
        available_ratio = random.uniform(0, 1)
        ratio_vector.append(available_ratio)
    for i in range(0, slots):
        # 这个slot是一次slice调度的时隙
        print("当前时隙为：", i)
        config_terminals(user_terminals, unavailable_terminals, int(num_users*ratio_vector[i]))
        distance_dict = get_info_by_time(user_path, i, common_satellites, num_users)
        # print(distance_dict[1][3743].altitude)
        print("配置用户终端后，当前可用用户终端数为：", len(user_terminals))
        # 先配置用户终端与哪个卫星相连
        for user_id, user_terminal in user_terminals.items():
            user_terminal.config_distances(distance_dict[user_id])
            user_terminal.connect_sat()
        # 这里需要绑定slice的带宽以及将slice配置给具体的mac scheduler，这里先不考虑
        # 下面这里考虑的是生成流量和对应数据包的传输
        # 每个slice调度的时隙下有几个short slot
        short_slots = int(slice_interval/time_interval)
        all_slot_results = []
        for j in range(0, short_slots):
            alloc_vec = scheduler.bandwidth_round_robin_schedule(BW_alloc)
            throughput, delay = scheduler.statistics_summary(alloc_vec)
            # 生成数据包
            for user_id, user_terminal in user_terminals.items():
                user_terminal.generate_flow(time_interval)
                    # 记录当前slot结果
            slot_result = {
                'slot': j,
                'time_ms': scheduler.current_time_ms - scheduler.MAC_SLOT_DURATION,  # 当前时间已经推进了
                'throughput': throughput,
                'delay': delay,
            }
            all_slot_results.append(slot_result)
        app_avg_throughput = {}
        app_final_delay = {}
        for m in range(1, num_users+1):
            # 计算平均吞吐量
            throughputs = [result['throughput'].get(m, 0) for result in all_slot_results]
            valid_throughputs = [t for t in throughputs if t > 0]
            if valid_throughputs:
                app_avg_throughput[m] = sum(valid_throughputs) / len(valid_throughputs)
            else:
                app_avg_throughput[m] = 0
            # 最终延迟
            ue = all_users[m]
            if ue.delay_pkt:
                app_final_delay[m] = sum(ue.delay_pkt) / len(ue.delay_pkt)
            else:
                app_final_delay[m] = 0
            # 打印结果
            flow_type = ue.flow_type
            print(f"用户 {m} 的 {flow_type} 流的平均吞吐量: {app_avg_throughput[m]/1e6:.3f} Mbps")
            print(f"用户 {m} 的 {flow_type} 流的最终延迟: {app_final_delay[m]:.2f} ms")
            print(f"剩余buffer包数: {ue.buffer.qsize()}")
            print(f"完成传输包数: {len(ue.delay_pkt)}")
        print(f"仿真时间推进到: {scheduler.current_time_ms}ms")



